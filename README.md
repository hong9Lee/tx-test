## 트랜잭션?  
트랜잭션은 작업의 완전성을 보장해주는 것이다.  
즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 주는 기능이다.

 - atomicity > 원자성 : 돈의 송금은 부분적인 성공을 허용하지 않는다. 트랜잭션의 연산들은 모두 성공하거나 반대로 모두 실패하는 성질
 - consistency > 일관성 : 트랜잭션이 끝난 후에 데이터베이스의 제약이나 규칙은 이전과 같이 유효해야한다.
 - isolation > 격리성 : 트랜잭션을 수행할 때 다른 트랜잭션으로부터 격리되어 있어 연속으로 실행한 것과 동일한 결과를 나타내야한다. 
내가 친구에게 돈을 보내는데 보내기 전에 친구 계좌에 돈이 들어가면 안된다.
- durability > 지속성 : 데이터는 영구적으로 보관된다. 송금의 경우 송금완료 후 금액은 시간이 지나도 그 금액이 계속 찍혀있어야한다.

***private 메서드에서는 @Transactional 어노테이션 적용이 불가능하다.***  
```
그 이유는 AOP가 프로시 패턴을 사용하기 때문이다.  
Spring은 AOP를 사용해서 @Transactional 애너테이션을 처리하고, 이 과정에서 동적으로 프록시 객체를 생성한다.   
생성된 프록시 객체는 원래의 Bean 객체를 대신해서 호출된다.  
private 메서드나 private 필드는 해당 클래스에서만 접근 가능하기 때문에 외부에서 접근해서 프록시 객체를 생성할 수 없게 되는 것이다.   
그래서 @Transactional 애너테이션을 가지고 있는 private 메서드에 접근하려고 해도 프록시 객체를 생성할 수 없기 때문에 해당 애너테이션을 무시하게 된다.  
```

***Transaction 전파 속성***  
이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것

Propagation.REQUIRED - 기본값 
- 부모 트랜잭션 내에서 실행하며, 부모 트랜잭션이 없을 경우 새로운 트랜잭션 생성

Propagation.REQUIRES_NEW   
- 매번 새로운 트랜잭션을 시작한다.  
호출한 곳에서 이미 트랜잭션이 설정되어 있다면(기존 연결이 있다면) 기존의 트랜잭션은 메소드가 종료할 때까지 잠시 대기 상태로 두고 자신의 트랜잭션을 실행한다.(부모 트랜잭션 상관X)  
새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳에는 롤백이 전파되지 않는다. 
			
Propagation.NESTED  
- 부모 트랜잭션이 존재한다면 중첩 트랜잭션을 생성합니다. 중첩된 트랜잭션 내부에서 롤백 발생시 해당 중첩 트랜잭션의 시작 지점 까지만 롤백됩니다. 중첩 트랜잭션은 부모 트랜잭션이 커밋될 때 같이 커밋됩니다.  
부모 트랜잭션이 존재하지 않는다면 새로운 트랜잭션을 생성합니다.

Propagation.MANDATORY   
- 부모 트랜잭션 내에서 실행되며, 부모 트랜잭션이 없을 경우 Exception이 발생한다. * 꼭 이전트랜잭션이 있어야 하는경우			  

Propagation.SUPPORT 
- 부모 트랜잭션이 존재하면 부모 트랜잭션으로 동작하고, 없을경우 non-transactional 하게 동작한다."			

Propagation.NOT_SUPPORT  
- non-transactional 로 실행되며 부모 트랜잭션이 존재하면 일시 정지한다. "			

Propagation.NEVER  
- non-transactional 로 실행되며 부모 트랜잭션이 존재하면 Exception이 발생한다."
